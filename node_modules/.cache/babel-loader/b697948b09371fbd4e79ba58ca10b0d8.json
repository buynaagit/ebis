{"ast":null,"code":"class Utils {\n  /**\n   * Get first character from first & last sentences of a username\n   * @param {String} name - Username\n   * @return {String} 2 characters string\n   */\n  static getNameInitial(name) {\n    let initials = name.match(/\\b\\w/g) || [];\n    return ((initials.shift() || \"\") + (initials.pop() || \"\")).toUpperCase();\n  }\n  /**\n   * Get current path related object from Navigation Tree\n   * @param {Array} navTree - Navigation Tree from directory 'configs/NavigationConfig'\n   * @param {String} path - Location path you looking for e.g '/app/dashboards/analytic'\n   * @return {Object} object that contained the path string\n   */\n\n\n  static getRouteInfo(navTree, path) {\n    if (navTree.path === path) {\n      return navTree;\n    }\n\n    let route;\n\n    for (let p in navTree) {\n      if (navTree.hasOwnProperty(p) && typeof navTree[p] === \"object\") {\n        route = this.getRouteInfo(navTree[p], path);\n\n        if (route) {\n          return route;\n        }\n      }\n    }\n\n    return route;\n  }\n  /**\n   * Get accessible color contrast\n   * @param {String} hex - Hex color code e.g '#3e82f7'\n   * @return {String} 'dark' or 'light'\n   */\n\n\n  static getColorContrast(hex) {\n    if (!hex) {\n      return \"dark\";\n    }\n\n    const threshold = 130;\n    const hRed = hexToR(hex);\n    const hGreen = hexToG(hex);\n    const hBlue = hexToB(hex);\n\n    function hexToR(h) {\n      return parseInt(cutHex(h).substring(0, 2), 16);\n    }\n\n    function hexToG(h) {\n      return parseInt(cutHex(h).substring(2, 4), 16);\n    }\n\n    function hexToB(h) {\n      return parseInt(cutHex(h).substring(4, 6), 16);\n    }\n\n    function cutHex(h) {\n      return h.charAt(0) === \"#\" ? h.substring(1, 7) : h;\n    }\n\n    const cBrightness = (hRed * 299 + hGreen * 587 + hBlue * 114) / 1000;\n\n    if (cBrightness > threshold) {\n      return \"dark\";\n    } else {\n      return \"light\";\n    }\n  }\n  /**\n   * Darken or lighten a hex color\n   * @param {String} color - Hex color code e.g '#3e82f7'\n   * @param {Number} percent - Percentage -100 to 100, positive for lighten, negative for darken\n   * @return {String} Darken or lighten color\n   */\n\n\n  static shadeColor(color, percent) {\n    let R = parseInt(color.substring(1, 3), 16);\n    let G = parseInt(color.substring(3, 5), 16);\n    let B = parseInt(color.substring(5, 7), 16);\n    R = parseInt(R * (100 + percent) / 100);\n    G = parseInt(G * (100 + percent) / 100);\n    B = parseInt(B * (100 + percent) / 100);\n    R = R < 255 ? R : 255;\n    G = G < 255 ? G : 255;\n    B = B < 255 ? B : 255;\n    const RR = R.toString(16).length === 1 ? `0${R.toString(16)}` : R.toString(16);\n    const GG = G.toString(16).length === 1 ? `0${G.toString(16)}` : G.toString(16);\n    const BB = B.toString(16).length === 1 ? `0${B.toString(16)}` : B.toString(16);\n    return `#${RR}${GG}${BB}`;\n  }\n  /**\n   * Convert RGBA to HEX\n   * @param {String} rgba - RGBA color code e.g 'rgba(197, 200, 198, .2)')'\n   * @return {String} HEX color\n   */\n\n\n  static rgbaToHex(rgba) {\n    const trim = str => str.replace(/^\\s+|\\s+$/gm, \"\");\n\n    const inParts = rgba.substring(rgba.indexOf(\"(\")).split(\",\"),\n          r = parseInt(trim(inParts[0].substring(1)), 10),\n          g = parseInt(trim(inParts[1]), 10),\n          b = parseInt(trim(inParts[2]), 10),\n          a = parseFloat(trim(inParts[3].substring(0, inParts[3].length - 1))).toFixed(2);\n    const outParts = [r.toString(16), g.toString(16), b.toString(16), Math.round(a * 255).toString(16).substring(0, 2)];\n    outParts.forEach(function (part, i) {\n      if (part.length === 1) {\n        outParts[i] = \"0\" + part;\n      }\n    });\n    return `#${outParts.join(\"\")}`;\n  }\n  /**\n   * Returns either a positive or negative\n   * @param {Number} number - number value\n   * @param {any} positive - value that return when positive\n   * @param {any} negative - value that return when negative\n   * @return {any} positive or negative value based on param\n   */\n\n\n  static getSignNum(number, positive, negative) {\n    if (number > 0) {\n      return positive;\n    }\n\n    if (number < 0) {\n      return negative;\n    }\n\n    return null;\n  }\n  /**\n   * Returns either ascending or descending value\n   * @param {Object} a - antd Table sorter param a\n   * @param {Object} b - antd Table sorter param b\n   * @param {String} key - object key for compare\n   * @return {any} a value minus b value\n   */\n\n\n  static antdTableSorter(a, b, key) {\n    if (typeof a[key] === \"number\" && typeof b[key] === \"number\") {\n      return a[key] - b[key];\n    }\n\n    if (typeof a[key] === \"string\" && typeof b[key] === \"string\") {\n      a = a[key].toLowerCase();\n      b = b[key].toLowerCase();\n      return a > b ? -1 : b > a ? 1 : 0;\n    }\n\n    return;\n  }\n  /**\n   * Filter array of object\n   * @param {Array} list - array of objects that need to filter\n   * @param {String} key - object key target\n   * @param {any} value  - value that excluded from filter\n   * @return {Array} a value minus b value\n   */\n\n\n  static filterArray(list, key, value) {\n    let data = list;\n\n    if (list) {\n      data = list.filter(item => item[key] === value);\n    }\n\n    return data;\n  }\n  /**\n   * Remove object from array by value\n   * @param {Array} list - array of objects\n   * @param {String} key - object key target\n   * @param {any} value  - target value\n   * @return {Array} Array that removed target object\n   */\n\n\n  static deleteArrayRow(list, key, value) {\n    let data = list;\n\n    if (list) {\n      data = list.filter(item => item[key] !== value);\n    }\n\n    return data;\n  }\n  /**\n   * Wild card search on all property of the object\n   * @param {Number | String} input - any value to search\n   * @param {Array} list - array for search\n   * @return {Array} array of object contained keyword\n   */\n\n\n  static wildCardSearch(list, input) {\n    const searchText = item => {\n      for (let key in item) {\n        if (item[key] == null) {\n          continue;\n        }\n\n        if (item[key].toString().toUpperCase().indexOf(input.toString().toUpperCase()) !== -1) {\n          return true;\n        }\n      }\n    };\n\n    list = list.filter(value => searchText(value));\n    return list;\n  }\n  /**\n   * Get Breakpoint\n   * @param {Object} screens - Grid.useBreakpoint() from antd\n   * @return {Array} array of breakpoint size\n   */\n\n\n  static getBreakPoint(screens) {\n    let breakpoints = [];\n\n    for (const key in screens) {\n      if (screens.hasOwnProperty(key)) {\n        const element = screens[key];\n\n        if (element) {\n          breakpoints.push(key);\n        }\n      }\n    }\n\n    return breakpoints;\n  }\n\n}\n\nexport default Utils;","map":{"version":3,"sources":["/Users/temka/ReactWorkpace/faroweb/src/utils/index.js"],"names":["Utils","getNameInitial","name","initials","match","shift","pop","toUpperCase","getRouteInfo","navTree","path","route","p","hasOwnProperty","getColorContrast","hex","threshold","hRed","hexToR","hGreen","hexToG","hBlue","hexToB","h","parseInt","cutHex","substring","charAt","cBrightness","shadeColor","color","percent","R","G","B","RR","toString","length","GG","BB","rgbaToHex","rgba","trim","str","replace","inParts","indexOf","split","r","g","b","a","parseFloat","toFixed","outParts","Math","round","forEach","part","i","join","getSignNum","number","positive","negative","antdTableSorter","key","toLowerCase","filterArray","list","value","data","filter","item","deleteArrayRow","wildCardSearch","input","searchText","getBreakPoint","screens","breakpoints","element","push"],"mappings":"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","sourcesContent":["class Utils {\n  /**\n   * Get first character from first & last sentences of a username\n   * @param {String} name - Username\n   * @return {String} 2 characters string\n   */\n  static getNameInitial(name) {\n    let initials = name.match(/\\b\\w/g) || [];\n    return ((initials.shift() || \"\") + (initials.pop() || \"\")).toUpperCase();\n  }\n\n  /**\n   * Get current path related object from Navigation Tree\n   * @param {Array} navTree - Navigation Tree from directory 'configs/NavigationConfig'\n   * @param {String} path - Location path you looking for e.g '/app/dashboards/analytic'\n   * @return {Object} object that contained the path string\n   */\n  static getRouteInfo(navTree, path) {\n    if (navTree.path === path) {\n      return navTree;\n    }\n    let route;\n    for (let p in navTree) {\n      if (navTree.hasOwnProperty(p) && typeof navTree[p] === \"object\") {\n        route = this.getRouteInfo(navTree[p], path);\n        if (route) {\n          return route;\n        }\n      }\n    }\n    return route;\n  }\n\n  /**\n   * Get accessible color contrast\n   * @param {String} hex - Hex color code e.g '#3e82f7'\n   * @return {String} 'dark' or 'light'\n   */\n  static getColorContrast(hex) {\n    if (!hex) {\n      return \"dark\";\n    }\n    const threshold = 130;\n    const hRed = hexToR(hex);\n    const hGreen = hexToG(hex);\n    const hBlue = hexToB(hex);\n    function hexToR(h) {\n      return parseInt(cutHex(h).substring(0, 2), 16);\n    }\n    function hexToG(h) {\n      return parseInt(cutHex(h).substring(2, 4), 16);\n    }\n    function hexToB(h) {\n      return parseInt(cutHex(h).substring(4, 6), 16);\n    }\n    function cutHex(h) {\n      return h.charAt(0) === \"#\" ? h.substring(1, 7) : h;\n    }\n    const cBrightness = (hRed * 299 + hGreen * 587 + hBlue * 114) / 1000;\n    if (cBrightness > threshold) {\n      return \"dark\";\n    } else {\n      return \"light\";\n    }\n  }\n\n  /**\n   * Darken or lighten a hex color\n   * @param {String} color - Hex color code e.g '#3e82f7'\n   * @param {Number} percent - Percentage -100 to 100, positive for lighten, negative for darken\n   * @return {String} Darken or lighten color\n   */\n  static shadeColor(color, percent) {\n    let R = parseInt(color.substring(1, 3), 16);\n    let G = parseInt(color.substring(3, 5), 16);\n    let B = parseInt(color.substring(5, 7), 16);\n    R = parseInt((R * (100 + percent)) / 100);\n    G = parseInt((G * (100 + percent)) / 100);\n    B = parseInt((B * (100 + percent)) / 100);\n    R = R < 255 ? R : 255;\n    G = G < 255 ? G : 255;\n    B = B < 255 ? B : 255;\n    const RR =\n      R.toString(16).length === 1 ? `0${R.toString(16)}` : R.toString(16);\n    const GG =\n      G.toString(16).length === 1 ? `0${G.toString(16)}` : G.toString(16);\n    const BB =\n      B.toString(16).length === 1 ? `0${B.toString(16)}` : B.toString(16);\n    return `#${RR}${GG}${BB}`;\n  }\n\n  /**\n   * Convert RGBA to HEX\n   * @param {String} rgba - RGBA color code e.g 'rgba(197, 200, 198, .2)')'\n   * @return {String} HEX color\n   */\n  static rgbaToHex(rgba) {\n    const trim = (str) => str.replace(/^\\s+|\\s+$/gm, \"\");\n    const inParts = rgba.substring(rgba.indexOf(\"(\")).split(\",\"),\n      r = parseInt(trim(inParts[0].substring(1)), 10),\n      g = parseInt(trim(inParts[1]), 10),\n      b = parseInt(trim(inParts[2]), 10),\n      a = parseFloat(\n        trim(inParts[3].substring(0, inParts[3].length - 1))\n      ).toFixed(2);\n    const outParts = [\n      r.toString(16),\n      g.toString(16),\n      b.toString(16),\n      Math.round(a * 255)\n        .toString(16)\n        .substring(0, 2),\n    ];\n\n    outParts.forEach(function (part, i) {\n      if (part.length === 1) {\n        outParts[i] = \"0\" + part;\n      }\n    });\n    return `#${outParts.join(\"\")}`;\n  }\n\n  /**\n   * Returns either a positive or negative\n   * @param {Number} number - number value\n   * @param {any} positive - value that return when positive\n   * @param {any} negative - value that return when negative\n   * @return {any} positive or negative value based on param\n   */\n  static getSignNum(number, positive, negative) {\n    if (number > 0) {\n      return positive;\n    }\n    if (number < 0) {\n      return negative;\n    }\n    return null;\n  }\n\n  /**\n   * Returns either ascending or descending value\n   * @param {Object} a - antd Table sorter param a\n   * @param {Object} b - antd Table sorter param b\n   * @param {String} key - object key for compare\n   * @return {any} a value minus b value\n   */\n  static antdTableSorter(a, b, key) {\n    if (typeof a[key] === \"number\" && typeof b[key] === \"number\") {\n      return a[key] - b[key];\n    }\n\n    if (typeof a[key] === \"string\" && typeof b[key] === \"string\") {\n      a = a[key].toLowerCase();\n      b = b[key].toLowerCase();\n      return a > b ? -1 : b > a ? 1 : 0;\n    }\n    return;\n  }\n\n  /**\n   * Filter array of object\n   * @param {Array} list - array of objects that need to filter\n   * @param {String} key - object key target\n   * @param {any} value  - value that excluded from filter\n   * @return {Array} a value minus b value\n   */\n  static filterArray(list, key, value) {\n    let data = list;\n    if (list) {\n      data = list.filter((item) => item[key] === value);\n    }\n    return data;\n  }\n\n  /**\n   * Remove object from array by value\n   * @param {Array} list - array of objects\n   * @param {String} key - object key target\n   * @param {any} value  - target value\n   * @return {Array} Array that removed target object\n   */\n  static deleteArrayRow(list, key, value) {\n    let data = list;\n    if (list) {\n      data = list.filter((item) => item[key] !== value);\n    }\n    return data;\n  }\n\n  /**\n   * Wild card search on all property of the object\n   * @param {Number | String} input - any value to search\n   * @param {Array} list - array for search\n   * @return {Array} array of object contained keyword\n   */\n  static wildCardSearch(list, input) {\n    const searchText = (item) => {\n      for (let key in item) {\n        if (item[key] == null) {\n          continue;\n        }\n        if (\n          item[key]\n            .toString()\n            .toUpperCase()\n            .indexOf(input.toString().toUpperCase()) !== -1\n        ) {\n          return true;\n        }\n      }\n    };\n    list = list.filter((value) => searchText(value));\n    return list;\n  }\n\n  /**\n   * Get Breakpoint\n   * @param {Object} screens - Grid.useBreakpoint() from antd\n   * @return {Array} array of breakpoint size\n   */\n  static getBreakPoint(screens) {\n    let breakpoints = [];\n    for (const key in screens) {\n      if (screens.hasOwnProperty(key)) {\n        const element = screens[key];\n        if (element) {\n          breakpoints.push(key);\n        }\n      }\n    }\n    return breakpoints;\n  }\n}\n\nexport default Utils;\n"]},"metadata":{},"sourceType":"module"}